From 1e7f9567b5def9e4741afc4e92c37908ab91c53e Mon Sep 17 00:00:00 2001
From: "pamenas" <mpamenas@gmail.com>
Date: Mon, 15 Feb 2021 18:33:49 +0100
Subject: [PATCH] applied scone metrics changes to driver

---
 driver/linux/driver.h       |  2 ++
 driver/linux/encl.c         | 17 ++++++++++++++++-
 driver/linux/ioctl.c        | 12 ++++++++++--
 driver/linux/main.c         | 25 +++++++++++++++++++++++++
 driver/linux/show_values.sh | 23 +++++++++++++++++++++++
 5 files changed, 76 insertions(+), 3 deletions(-)
 create mode 100755 driver/linux/show_values.sh

diff --git a/driver/linux/driver.h b/driver/linux/driver.h
index 4024f48..28a6590 100644
--- a/driver/linux/driver.h
+++ b/driver/linux/driver.h
@@ -12,6 +12,8 @@
 #include "sgx_user.h"
 #include "sgx.h"
 
+#define PATCH_METRICS 1
+
 #define SGX_EINIT_SPIN_COUNT	20
 #define SGX_EINIT_SLEEP_COUNT	50
 #define SGX_EINIT_SLEEP_TIME	20
diff --git a/driver/linux/encl.c b/driver/linux/encl.c
index b9746c5..089310f 100644
--- a/driver/linux/encl.c
+++ b/driver/linux/encl.c
@@ -13,7 +13,18 @@
 #include "sgx.h"
 #include "dcap.h"
 #include <linux/version.h>
+#include <linux/moduleparam.h>
 
+extern unsigned int sgx_nr_enclaves;
+static unsigned int sgx_nr_low_pages = SGX_NR_LOW_PAGES;
+static unsigned int sgx_nr_high_pages = SGX_NR_HIGH_PAGES;
+static unsigned int sgx_loaded_back = 0;
+static unsigned int sgx_nr_marked_old = 0;
+
+module_param(sgx_nr_low_pages, uint, 0440);
+module_param(sgx_nr_high_pages, uint, 0440);
+module_param(sgx_loaded_back, uint, 0440);
+module_param(sgx_nr_marked_old, uint, 0440);
 
 /*
  * ELDU: Load an EPC page as unblocked. For more info, see "OS Management of EPC
@@ -58,6 +69,8 @@ static int __sgx_encl_eldu(struct sgx_encl_page *encl_page,
 		ret = -EFAULT;
 	}
 
+    sgx_loaded_back++;
+
 	kunmap_atomic((void *)(unsigned long)(pginfo.metadata - b.pcmd_offset));
 	kunmap_atomic((void *)(unsigned long)pginfo.contents);
 
@@ -473,7 +486,8 @@ void sgx_encl_release(struct kref *ref)
 #else
 	unsigned long index;
 #endif
-
+	if (test_bit(SGX_ENCL_CREATED, &encl->flags))
+        sgx_nr_enclaves--;
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
 	radix_tree_for_each_slot(slot, &encl->page_tree, &iter, 0) {
 		entry = *slot;
@@ -748,6 +762,7 @@ static int sgx_encl_test_and_clear_young_cb(pte_t *ptep,
 	ret = pte_young(*ptep);
 	if (ret) {
 		pte = pte_mkold(*ptep);
+		sgx_nr_marked_old++;
 		set_pte_at((struct mm_struct *)data, addr, ptep, pte);
 	}
 
diff --git a/driver/linux/ioctl.c b/driver/linux/ioctl.c
index e8aa47a..9d3532a 100644
--- a/driver/linux/ioctl.c
+++ b/driver/linux/ioctl.c
@@ -17,7 +17,14 @@
 #include "encls.h"
 
 #include <linux/version.h>
+#include <linux/moduleparam.h>
 
+unsigned int sgx_init_enclaves = 0;
+unsigned int sgx_nr_enclaves = 0;
+unsigned int sgx_nr_added_pages = 0;
+module_param(sgx_init_enclaves, uint, 0440);
+module_param(sgx_nr_enclaves, uint, 0440);
+module_param(sgx_nr_added_pages, uint, 0440);
 
 static struct sgx_va_page *sgx_encl_grow(struct sgx_encl *encl)
 {
@@ -116,8 +123,8 @@ static int sgx_encl_create(struct sgx_encl *encl, struct sgx_secs *secs)
 	encl->attributes_mask = SGX_ATTR_DEBUG | SGX_ATTR_MODE64BIT | SGX_ATTR_KSS;
 
 	/* Set only after completion, as encl->lock has not been taken. */
-	set_bit(SGX_ENCL_CREATED, &encl->flags);
-
+	set_bit(SGX_ENCL_CREATED, &encl->flags);
+    sgx_nr_enclaves++;
 	return 0;
 
 err_out:
@@ -603,6 +610,7 @@ static int sgx_encl_init(struct sgx_encl *encl, struct sgx_sigstruct *sigstruct,
 		ret = -EPERM;
 	} else {
 		set_bit(SGX_ENCL_INITIALIZED, &encl->flags);
+		sgx_init_enclaves++;
 	}
 
 err_out:
diff --git a/driver/linux/main.c b/driver/linux/main.c
index a75969b..65cc9b1 100644
--- a/driver/linux/main.c
+++ b/driver/linux/main.c
@@ -31,6 +31,16 @@ static int sgx_nr_epc_sections;
 static struct task_struct *ksgxd_tsk;
 static DECLARE_WAIT_QUEUE_HEAD(ksgxd_waitq);
 
+static unsigned int sgx_nr_total_epc_pages = 0;
+static unsigned int sgx_nr_alloc_pages = 0;
+static unsigned int sgx_nr_reclaimed = 0;
+static unsigned int sgx_nr_evicted = 0;
+module_param(sgx_nr_epc_sections, int, 0440);
+module_param(sgx_nr_total_epc_pages, uint, 0440);
+module_param(sgx_nr_alloc_pages, uint, 0440);
+module_param(sgx_nr_reclaimed, uint, 0440);
+module_param(sgx_nr_evicted, uint, 0440);
+
 /*
  * These variables are part of the state of the reclaimer, and must be accessed
  * with sgx_reclaimer_lock acquired.
@@ -302,6 +312,7 @@ static void sgx_reclaimer_write(struct sgx_epc_page *epc_page,
 		if (ret)
 			goto out;
 
+		sgx_nr_evicted++;
 		sgx_encl_ewb(encl->secs.epc_page, &secs_backing);
 
 		sgx_free_epc_page(encl->secs.epc_page);
@@ -373,6 +384,7 @@ static void sgx_reclaim_pages(void)
 
 		mutex_lock(&encl_page->encl->lock);
 		encl_page->desc |= SGX_ENCL_PAGE_BEING_RECLAIMED;
+		sgx_nr_reclaimed++;
 		mutex_unlock(&encl_page->encl->lock);
 		continue;
 
@@ -423,6 +435,17 @@ static unsigned long sgx_nr_free_pages(void)
 	return cnt;
 }
 
+static int get_sgx_nr_free_pages(char *buffer, const struct kernel_param *kp)
+{
+	return sprintf(buffer, "%lu\n", sgx_nr_free_pages());
+}
+
+static struct kernel_param_ops param_ops_sgx_nr_free_pages = {
+	.get = get_sgx_nr_free_pages,
+};
+
+module_param_cb(sgx_nr_free_pages, &param_ops_sgx_nr_free_pages, NULL, 0440);
+
 static bool sgx_should_reclaim(unsigned long watermark)
 {
 	return sgx_nr_free_pages() < watermark &&
@@ -644,6 +667,7 @@ struct sgx_epc_page *sgx_alloc_epc_page(void *owner, bool reclaim)
 		cond_resched();
 	}
 
+	sgx_nr_alloc_pages++; // ignore races ..
 	if (sgx_should_reclaim(SGX_NR_LOW_PAGES))
 		wake_up(&ksgxd_waitq);
 
@@ -746,6 +770,7 @@ static bool __init sgx_page_cache_init(void)
 		}
 
 		sgx_nr_epc_sections++;
+		sgx_nr_total_epc_pages += (size / PAGE_SIZE);
 	}
 
 	if (!sgx_nr_epc_sections) {
diff --git a/driver/linux/show_values.sh b/driver/linux/show_values.sh
new file mode 100755
index 0000000..af9e2d8
--- /dev/null
+++ b/driver/linux/show_values.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+#
+# (C) Christof Fetzer, 2017
+
+METRICS="sgx_nr_total_epc_pages \
+    sgx_nr_free_pages \
+    sgx_nr_low_pages \
+    sgx_nr_high_pages \
+    sgx_nr_marked_old \
+    sgx_nr_evicted \
+    sgx_nr_alloc_pages \
+    sgx_nr_reclaimed \
+    sgx_init_enclaves \
+    sgx_nr_added_pages \
+    sgx_nr_enclaves \
+    sgx_loaded_back \
+    sgx_nr_epc_sections \
+    "
+MODPATH="/sys/module/intel_sgx/parameters/"
+
+for metric in $METRICS ; do
+    echo "$metric= `cat $MODPATH/$metric`"
+done
-- 
2.17.1

